<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>笨笨三脚猫</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="笨笨三脚猫">
<meta property="og:url" content="https://chenfengying.github.io/index.html">
<meta property="og:site_name" content="笨笨三脚猫">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="笨笨三脚猫">
  
    <link rel="alternate" href="/atom.xml" title="笨笨三脚猫" type="application/atom+xml">
  
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">笨笨三脚猫</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://chenfengying.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Java-Collection" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2025/02/16/Java-Collection/" class="article-date">
  <time datetime="2025-02-16T19:25:02.000Z" itemprop="datePublished">2025-02-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2025/02/16/Java-Collection/">Java Collection</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#Type of Java Collection </p>
<ol>
<li>List(Ordered, allow duplicates)<br> Implementation: ArrayList ,LinkedList,Vector<br> Element are stored in an ordered sequence(index-based)<br> allow duplicate values<br> Example : ArrayList<integer> list=new ArrayList&lt;&gt;();</integer></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://chenfengying.github.io/2025/02/16/Java-Collection/" data-id="cm780tvng0005c0vlk7u1r93z" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Jmeter-issue" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/08/27/Jmeter-issue/" class="article-date">
  <time datetime="2022-08-27T08:24:42.000Z" itemprop="datePublished">2022-08-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Jmeter/">Jmeter</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/08/27/Jmeter-issue/">Jmeter issue</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>use the results.jtl to generate aggregate report fail :</p>
<p>error : Ubable to access jarfile …./CMSRunner2.2.jar.</p>
<p>so i checked the file in lib, my version are cmdrunner-2.3.jar</p>
<p>so i go to bin folder to edit “JmeterPluginsCMD.bat” to change to cmdrunner-2.2.jar. then run the scripts agagin<br>then it works</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://chenfengying.github.io/2022/08/27/Jmeter-issue/" data-id="cm780tvnj0007c0vlq962r5tp" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-eclipse-connect-the-mysql-database" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/07/03/eclipse-connect-the-mysql-database/" class="article-date">
  <time datetime="2022-07-03T14:23:37.000Z" itemprop="datePublished">2022-07-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/07/03/eclipse-connect-the-mysql-database/">eclipse connect the mysql database</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="this-is-a-test-he"><a href="#this-is-a-test-he" class="headerlink" title="this is a test he"></a>this is a test he</h1><p>当输入如下代码：<br>class Solution:<br>    def twoSum(self, nums: List[int], target: int) -&gt; List[int]:  </p>
<p>代码结果为：<br>NameError: name ‘List’ is not defined</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://chenfengying.github.io/2022/07/03/eclipse-connect-the-mysql-database/" data-id="cm780tvo9000mc0vla09ct2qv" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Automation/">Automation</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-pycharm-调试技巧" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/10/11/pycharm-调试技巧/" class="article-date">
  <time datetime="2021-10-11T19:49:23.000Z" itemprop="datePublished">2021-10-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/10/11/pycharm-调试技巧/">pycharm 调试技巧</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>新手必会，pycharm的调试功能(史上最详篇)<br>前言<br>Debug调试，是一项学习编程人员的重要技能。只有当你学会 debug 了以后，才可以正确的知道程序的走向流程是如何的，今天就来给大家介绍一下 pycharm 中的 debug 功能！</p>
<p>debug的前世<br>在正式讲解之前，先来了解下 debug 这个词的由来，就像我们初学Python 时，先要了解下它历史的由来。</p>
<p>1937年，美国青年霍华德·艾肯找到IBM公司为其投资200万美元研制计算机，第一台成品艾肯把它取名为：马克1号（mark1），又叫“自动序列受控计算机”，从这时起IBM公司由生产制表机，肉铺磅秤，咖啡研磨机等乱七八糟玩意儿行业，正式跨进“计算机”领地。<br>为马克1号编制程序的是哈佛的一位女数学家葛丽斯·莫雷·霍波，有一天，她在调试程序时出现故障，拆开继电器后，发现有只飞蛾被夹扁在触点中间，从而“卡”住了机器的运行。于是，霍波诙谐的把程序故障统称为“臭虫（BUG）”，把排除程序故障叫DEBUG，而这奇怪的“称呼”，后来成为计算机领域的专业行话。从而debug意为排除程序故障的意思。<br>百度百科<br>看了上面的小故事，debug 一词的由来，是由 bug 词得来的，bug 是臭虫的意思，debug 就是解决臭虫。</p>
<p>在如今的互联网时代，多少你肯定听说过 bug 这个词，比如什么什么软件又出 bug 了！说的就是软件在使用的过程中，程序出现了一些错误。故称之为 bug。</p>
<p><strong>而 debug 则是通过工具来对代码进行调试，一步步找出程序中出现 bug 的位置，也就是程序中具体错误代码的位置。</strong>就像故事中所说，debug过程就是在解决虫子一样。。</p>
<p>pycharm 中的 debug 模式<br>来步入今天的正题。</p>
<p>首先，还是用示例说话，我们书写一段简短的代码，来帮我们完成今天要讲的内容。</p>
<p>def sum_demo(x, y):<br>    for _ in range(2):<br>        x += 1<br>        y += 1<br>        result = x + y<br>    return result</p>
<p>if <strong>name</strong> == ‘<strong>main</strong>‘:<br>    result = sum_demo(1, 1)<br>    print(result)<br>肉眼识别下，猜猜结果是多少呢？初学者可能没见过 for 循环中的下划线，在 Python 中是占位符的意思，因为单纯的循环两次而已，并不用到它的循环结果。最终 result 会输出 6 。</p>
<p>在 pycharm 中，如何开启 debug 调试，一共有三种进入的方法，如下（下图均可点开放大观看）：</p>
<p>方法一：</p>
<p>方法二：</p>
<p>方法三：</p>
<p>还有一种方法，就是 pycharm 导航栏处，有个run，点开以后即可看到 debug ，这里就不截图演示了。</p>
<p>单纯的进入 debug 模式，你会发现，与正常的 run 去运行程序没有差异。差异就是 pycharm 的控制台部分，从 run 跑到了 debug 显示。</p>
<p>接下来要讲的，才是 debug 中的重中之重，即断点调试！</p>
<p>debug 的断点调试<br>断点调试，英文 breakpoint。用大白话来解释下，断点调试其实就是在程序自动运行的过程中，你在代码某一处打上了断点，当程序跑到你设置的断点位置处，则会中断下来，此时你可以看到之前运行过的所有程序变量。</p>
<p>来继续刚才的演示，pycharm 中如何设置断点。</p>
<p>点击前：</p>
<p>点击后，皮一下，每行代码都设置上断点：</p>
<p>设置完断点后，开启 debug 调试模式运行下，看到结果：</p>
<p>看到了这么多新摆设，是不是有点怕了！不怕，咱们先来从控制台每个按钮讲起：</p>
<p>如果要是忘记中文意思的话，没有关系，鼠标指到按钮处，悬浮一会儿，会有英文提示的。继续再来说横排按钮：</p>
<p>其中，横排最重要，经常用到的按钮，来解释一下，自己鼠标悬浮去看英文即可：</p>
<p>step over（F8快捷键）：在单步执行时，在函数内遇到子函数时不会进入子函数内单步执行，而是将子函数整个执行完再停止，也就是把子函数整个作为一步。在不存在子函数的情况下是和step into效果一样的。简单的说就是，程序代码越过子函数，但子函数会执行，且不进入。</p>
<p>step into（F7快捷键）：在单步执行时，遇到子函数就进入并且继续单步执行，有的会跳到源代码里面去执行。</p>
<p>step into my code（Alt+Shift+F7快捷键）：在单步执行时，遇到子函数就进入并且继续单步执行，不会进入到源码中。</p>
<p>step out（Shift+F8快捷键）：假如进入了一个函数体中，你看了两行代码，不想看了，跳出当前函数体内，返回到调用此函数的地方，即使用此功能即可。</p>
<p>Resume program(F9快捷键)：继续恢复程序，直接运行到下一断点处。</p>
<p>以上四个功能，就是最常用的功能，一般操作步骤就是，设置好断点，debug运行，然后 F8 单步调试，遇到想进入的函数 F7 进去，想出来在 shift + F8，跳过不想看的地方，直接设置下一个断点，然后 F9 过去。</p>
<p>示例演示<br>上面的基础概念明白了以后，直接用图片示例演示下：</p>
<p>1.设置初步断点</p>
<p>2.F7 进入函数</p>
<p>3.F8 单步调试，往下执行代码</p>
<p>继续 F8 单步调试，往下执行代码：</p>
<p>继续 F8 单步调试：</p>
<p>继续 F8 单步调试：</p>
<p>4.看够了循环，想直接看最终 result 加完的结果，结果处打断点，直接 F9</p>
<p>以上就是断点调试的全过程。看完之后，理解了吗~是不是顿时明白了断点调试的重要性，使用断点可以快速帮助我们理解程序中的各处逻辑！</p>
<p>结语<br>看到这里，基本的调试，相信你认真看完的话，已经可以上手使用了！但是要拓展的点还有很多，比如 pycharm 为什么在工程性的程序中颇受欢迎，因为它实在是太强大了。。。还有一些拓展功能，大家可以去慕课网上搜下IntelliJ IDEA神器使用技巧 ,老师讲的非常详细，涉及到许多技巧，idea和pycharm是一家公司出的，所以使用上的技巧也是一样的，可以融会贯通。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://chenfengying.github.io/2021/10/11/pycharm-调试技巧/" data-id="cm780tvoi000vc0vl5evt0bv8" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-python3-typing" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/10/11/python3-typing/" class="article-date">
  <time datetime="2021-10-11T19:30:11.000Z" itemprop="datePublished">2021-10-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/10/11/python3-typing/">python3- typing</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="NameError-name-‘List’-is-not-defined"><a href="#NameError-name-‘List’-is-not-defined" class="headerlink" title="NameError: name ‘List’ is not defined"></a>NameError: name ‘List’ is not defined</h1><p>当输入如下代码：<br>class Solution:<br>    def twoSum(self, nums: List[int], target: int) -&gt; List[int]:  </p>
<p>代码结果为：<br>NameError: name ‘List’ is not defined</p>
<h1 id="先说下解决办法："><a href="#先说下解决办法：" class="headerlink" title="先说下解决办法："></a>先说下解决办法：</h1><p>只需要导入 typing包即可</p>
<p>from typing import List</p>
<p>typing包到底做什么事情呢？<br>由于python在具体使用时，尤其是在函数参数中，对于变量的类型并不会过多关注，虽然更加方便，但会使代码的易读性变差，有时候自己都不知道传入的是什么参数。因此在python3中引入了一个typing模块，这个模块可以很好解决这个问题。在python2中是无法实现参数类型说明的。</p>
<p>例如：</p>
<p>def twoSum(self, nums: List[int], target: int) -&gt; List[int]:<br>1<br>该函数中，参数nums 为list类型，target为int型整数，最终返回值为list类型。</p>
<p>从中可以看出，typing模块的作用：</p>
<p>作为类型检查，防止运行时出现参数和返回值类型不对的情况<br>作为开发文档附加说明，方便使用函数时传入和返回正确的参数，利于开发效率</p>
<h1 id="该模块并不会实际影响到程序的运行，不会报错，但是会有提示。"><a href="#该模块并不会实际影响到程序的运行，不会报错，但是会有提示。" class="headerlink" title="该模块并不会实际影响到程序的运行，不会报错，但是会有提示。"></a>该模块并不会实际影响到程序的运行，不会报错，但是会有提示。</h1><p>typing常用类型：</p>
<p>int,long,float: 整型,长整形,浮点型;</p>
<p>bool,str: 布尔型，字符串类型；</p>
<p>List, Tuple, Dict, Set:列表，元组，字典, 集合;</p>
<p>Iterable,Iterator:可迭代类型，迭代器类型；</p>
<p>Generator：生成器类型；</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://chenfengying.github.io/2021/10/11/python3-typing/" data-id="cm780tvop0013c0vlx7coul0i" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-深入解析常见三次握手异常" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/08/10/深入解析常见三次握手异常/" class="article-date">
  <time datetime="2021-08-10T08:33:32.000Z" itemprop="datePublished">2021-08-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Internet-Basic/">Internet Basic</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/08/10/深入解析常见三次握手异常/">深入解析常见三次握手异常</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在后端接口性能指标中一类重要的指标就是接口耗时。具体包括平均响应时间 TP90、TP99 耗时值等。这些值越低越好，一般来说是几毫秒，或者是几十毫秒。如果响应时间一旦过长，比如超过了 1 秒，在用户侧就能感觉到非常明显的卡顿。如果长此以往，用户可能就直接用脚投票，卸载我们的 App 了。</p>
<p>在正常情况下一次 TCP 连接耗时也就大约是一次 RTT 多一点。但事情不一定总是这么美好，总会有意外发生。在某些情况下，可能会导致连接耗时上涨、CPU 处理开销增加、甚至是超时失败。</p>
<p>今天飞哥就来说一下我在线上遇到过的那些 TCP 握手相关的各种异常情况。</p>
<h1 id="一、客户端-connect-异常"><a href="#一、客户端-connect-异常" class="headerlink" title="一、客户端 connect 异常"></a>一、客户端 connect 异常</h1><p>端口号和 CPU 消耗这二者听起来感觉没啥太大联系。但我却遭遇过因为端口号不足导致 CPU 消耗大幅上涨的情况。来听飞哥分析分析为啥会出现这种问题！</p>
<p>客户端在发起 connect 系统调用的时候，主要工作就是端口选择（参见TCP连接中客户端的端口号是如何确定的？）。</p>
<p>在选择的过程中，有个大循环，从 ip_local_port_range 的一个随机位置开始把这个范围遍历一遍，找到可用端口则退出循环。如果端口很充足，那么循环只需要执行少数几次就可以退出。但假设说端口消耗掉很多已经不充足，或者干脆就没有可用的了。那么这个循环就得执行很多遍。我们来看下详细的代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">int __inet_hash_connect(...)</span><br><span class="line">&#123;</span><br><span class="line"> inet_get_local_port_range(&amp;low, &amp;high);</span><br><span class="line"> remaining = (high - low) + 1;</span><br><span class="line"></span><br><span class="line"> for (i = 1; i &lt;= remaining; i++) &#123;</span><br><span class="line">  // 其中 offset 是一个随机数</span><br><span class="line">  port = low + (i + offset) % remaining;</span><br><span class="line">  head = &amp;hinfo-&gt;bhash[inet_bhashfn(net, port,</span><br><span class="line">     hinfo-&gt;bhash_size)];</span><br><span class="line"></span><br><span class="line">  //加锁</span><br><span class="line">  spin_lock(&amp;head-&gt;lock); </span><br><span class="line"></span><br><span class="line">  //一大段的选择端口逻辑</span><br><span class="line">  //......</span><br><span class="line">  //选择成功就 goto ok</span><br><span class="line">  //不成功就 goto next_port</span><br><span class="line"></span><br><span class="line">  next_port:</span><br><span class="line">   //解锁</span><br><span class="line">   spin_unlock(&amp;head-&gt;lock); </span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在每次的循环内部需要等待锁，以及在哈希表中执行多次的搜索。注意这里的是自旋锁，是一种非阻塞的锁，如果资源被占用，进程并不会被挂起，而是会占用 CPU 去不断尝试获取锁。</p>
<p>但假设端口范围 ip_local_port_range 配置的是 10000 - 30000， 而且已经用尽了。那么每次当发起连接的时候都需要把循环执行两万遍才退出。这时会涉及大量的 HASH 查找以及自旋锁等待开销，系统态 CPU 将会出现大幅度的上涨。</p>
<p>这是线上截取到的正常时的 connect 系统调用耗时，是 22 us（微秒）。</p>
<p>Image</p>
<p>这个是我们一台服务器在端口不足情况下 connect 开销，是 2581 us（微秒）。</p>
<p>Image</p>
<p>从上两张图中可以看出，异常情况下的 connect 耗时是正常情况下的 100 多倍。虽然换算成毫秒只有 2 ms 多一点，但是要知道这消耗的全是 CPU 时间。</p>
<h1 id="二、第一次握手丢包"><a href="#二、第一次握手丢包" class="headerlink" title="二、第一次握手丢包"></a>二、第一次握手丢包</h1><p>服务器在响应来自客户端的第一次握手请求的时候，会判断一下半连接队列和全连接队列是否溢出。如果发生溢出，可能会直接将握手包丢弃，而不会反馈给客户端。接下来我们分别来详细看一下。</p>
<p>2.1 半连接队列满<br>我们来看下半连接队列在何种情况下会导致丢包。</p>
<figure class="highlight plain"><figcaption><span>net/ipv4/tcp_ipv4.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int tcp_v4_conn_request(struct sock *sk, struct sk_buff *skb)</span><br><span class="line">&#123;</span><br><span class="line"> //看看半连接队列是否满了</span><br><span class="line"> if (inet_csk_reqsk_queue_is_full(sk) &amp;&amp; !isn) &#123;</span><br><span class="line">  want_cookie = tcp_syn_flood_action(sk, skb, &quot;TCP&quot;);</span><br><span class="line">  if (!want_cookie)</span><br><span class="line">   goto drop;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> //看看全连接队列是否满了</span><br><span class="line"> ...</span><br><span class="line">drop:</span><br><span class="line"> NET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENDROPS);</span><br><span class="line"> return 0; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面代码中，inet_csk_reqsk_queue_is_full 如果返回 true 就表示半连接队列满了，另外 tcp_syn_flood_action 判断是否打开了内核参数 tcp_syncookies，如果未打开则返回 false。</p>
<figure class="highlight plain"><figcaption><span>net/ipv4/tcp_ipv4.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">bool tcp_syn_flood_action(...)</span><br><span class="line">&#123;</span><br><span class="line"> bool want_cookie = false;</span><br><span class="line"></span><br><span class="line"> if (sysctl_tcp_syncookies) &#123;</span><br><span class="line">  want_cookie = true;</span><br><span class="line"> &#125; </span><br><span class="line"> return want_cookie;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是说，如果半连接队列满了，而且 ipv4.tcp_syncookies 参数设置为 0，那么来自客户端的握手包将 goto drop，意思就是直接丢弃！</p>
<p>SYN Flood 攻击就是通过消耗光服务器上的半连接队列来使得正常的用户连接请求无法被响应。不过在现在的 Linux 内核里只要打开 tcp_syncookies，半连接队列满了仍然也还可以保证正常握手的进行。</p>
<p>2.2 全连接队列满<br>我们注意到当半连接队列判断通过以后，紧接着还有全连接队列满的相关判断。如果这个条件成立，服务器对握手包的处理还是会 goto drop，丢弃了之。我们来看下源码：</p>
<figure class="highlight plain"><figcaption><span>net/ipv4/tcp_ipv4.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int tcp_v4_conn_request(struct sock *sk, struct sk_buff *skb)</span><br><span class="line">&#123;</span><br><span class="line"> //看看半连接队列是否满了</span><br><span class="line"> ...</span><br><span class="line"></span><br><span class="line"> //看看全连接队列是否满了</span><br><span class="line"> if (sk_acceptq_is_full(sk) &amp;&amp; inet_csk_reqsk_queue_young(sk) &gt; 1) &#123;</span><br><span class="line">  NET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENOVERFLOWS);</span><br><span class="line">  goto drop;</span><br><span class="line"> &#125;</span><br><span class="line"> ...</span><br><span class="line">drop:</span><br><span class="line"> NET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENDROPS);</span><br><span class="line"> return 0; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sk_acceptq_is_full 来判断全连接队列是否满了，inet_csk_reqsk_queue_young 判断的是有没有 young_ack（未处理完的半连接请求）。</p>
<p>这段代码可以看到，假如全连接队列满的情况下，且同时有 young_ack ，那么内核同样直接丢掉该 SYN 握手包。</p>
<p>2.3 客户端发起重试<br>假设说服务器侧发生了全/半连接队列溢出而导致的丢包。那么从转换到客户端视角来看就是 SYN 包没有任何响应。</p>
<p>好在客户端在发出握手包的时候，开启了一个重传定时器。如果收不到预期的 synack 的话，超时重传的逻辑就会开始执行。不过重传计时器的时间单位都是以秒来计算的，这意味着，如果有握手重传发生，即使第一次重传就能成功，那接口最快响应也是 1 s 以后的事情了。这对接口耗时影响非常的大。</p>
<p>Image</p>
<p>我们来详细看下重传相关的逻辑。服务器在 connect 发出 syn 后就开启了重传定时器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">int tcp_connect(struct sock *sk)</span><br><span class="line">&#123;</span><br><span class="line"> ...</span><br><span class="line"> //实际发出 syn</span><br><span class="line"> err = tp-&gt;fastopen_req ? tcp_send_syn_data(sk, buff) :</span><br><span class="line">       tcp_transmit_skb(sk, buff, 1, sk-&gt;sk_allocation);</span><br><span class="line"></span><br><span class="line"> //启动重传定时器</span><br><span class="line"> inet_csk_reset_xmit_timer(sk, ICSK_TIME_RETRANS,</span><br><span class="line">      inet_csk(sk)-&gt;icsk_rto, TCP_RTO_MAX);</span><br><span class="line">&#125;</span><br><span class="line">在定时器设置中传入的 inet_csk(sk)-&gt;icsk_rto 是超时时间，该值初始的时候被设置为了 1 秒。</span><br><span class="line"></span><br><span class="line">//file:ipv4/tcp_output.c</span><br><span class="line">void tcp_connect_init(struct sock *sk)</span><br><span class="line">&#123;</span><br><span class="line"> //初始化为 TCP_TIMEOUT_INIT </span><br><span class="line"> inet_csk(sk)-&gt;icsk_rto = TCP_TIMEOUT_INIT;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//file: include/net/tcp.h</span><br><span class="line">#define TCP_TIMEOUT_INIT ((unsigned)(1*HZ)) </span><br><span class="line">在一些老版本的内核，比如 2.6 里，重传定时器的初始值是 3 秒。</span><br><span class="line"></span><br><span class="line">//内核版本：2.6.32</span><br><span class="line">//file: include/net/tcp.h</span><br><span class="line">#define TCP_TIMEOUT_INIT ((unsigned)(3*HZ))</span><br><span class="line">如果能正常接收到服务器响应的 synack，那么客户端的这个定时器会清除。这段逻辑在 tcp_rearm_rto 里。（tcp_rcv_state_process -&gt; tcp_rcv_synsent_state_process -&gt; tcp_ack -&gt; tcp_clean_rtx_queue -&gt; tcp_rearm_rto）</span><br><span class="line"></span><br><span class="line">//file:net/ipv4/tcp_input.c</span><br><span class="line">void tcp_rearm_rto(struct sock *sk)</span><br><span class="line">&#123;</span><br><span class="line"> inet_csk_clear_xmit_timer(sk, ICSK_TIME_RETRANS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果服务器端发生了丢包，那么定时器到时后会进行回调函数 tcp_write_timer 中进行重传。</p>
<p>其实不只是握手，连接状态的超时重传也是在这里完成的。不过这里我们只讨论握手重传的情况。</p>
<figure class="highlight plain"><figcaption><span>net/ipv4/tcp_timer.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">static void tcp_write_timer(unsigned long data)</span><br><span class="line">&#123;</span><br><span class="line"> tcp_write_timer_handler(sk);</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void tcp_write_timer_handler(struct sock *sk)</span><br><span class="line">&#123;</span><br><span class="line"> //取出定时器类型。</span><br><span class="line"> event = icsk-&gt;icsk_pending;</span><br><span class="line"></span><br><span class="line"> switch (event) &#123;</span><br><span class="line"> case ICSK_TIME_RETRANS:</span><br><span class="line">  icsk-&gt;icsk_pending = 0;</span><br><span class="line">  tcp_retransmit_timer(sk);</span><br><span class="line">  break;</span><br><span class="line"> ......</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>tcp_retransmit_timer 是重传的主要函数。在这里完成重传，以及下一次定时器到期时间的设置。</p>
<figure class="highlight plain"><figcaption><span>net/ipv4/tcp_timer.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">void tcp_retransmit_timer(struct sock *sk)</span><br><span class="line">&#123;</span><br><span class="line"> ...</span><br><span class="line"></span><br><span class="line"> //超过了重传次数则退出</span><br><span class="line"> if (tcp_write_timeout(sk))</span><br><span class="line">  goto out;</span><br><span class="line"></span><br><span class="line"> //重传</span><br><span class="line"> if (tcp_retransmit_skb(sk, tcp_write_queue_head(sk)) &gt; 0) &#123;</span><br><span class="line">  //重传失败</span><br><span class="line">  ......</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">//退出前重新设置下一次超时时间</span><br><span class="line">out_reset_timer:</span><br><span class="line"> //计算超时时间</span><br><span class="line"> if (sk-&gt;sk_state == TCP_ESTABLISHED )&#123;</span><br><span class="line">  ......</span><br><span class="line"> &#125; else &#123;</span><br><span class="line">  icsk-&gt;icsk_rto = min(icsk-&gt;icsk_rto &lt;&lt; 1, TCP_RTO_MAX);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> //设置</span><br><span class="line"> inet_csk_reset_xmit_timer(sk, ICSK_TIME_RETRANS, icsk-&gt;icsk_rto, TCP_RTO_MAX); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>tcp_write_timeout 是判断是否重试过多，如果是则退出重试逻辑。</p>
<p>tcp_write_timeout 的判断逻辑其实也有点小复杂。对于 SYN 握手包主要是判断依据是 net.ipv4.tcp_syn_retries，但其实并不是简单对比次数，而是转化成了时间进行对比。所以如果你在线上看到实际重传次数和对应内核参数不一致也不用太奇怪。</p>
<p>接着在 tcp_retransmit_timer 重发了发送队列里的头元素。而且还设置了下一次超时的时间，为前一次的两倍（左移操作相当于乘2）。</p>
<p>2.4 实际抓包结果<br>我们来看一个因为服务器端响应第一次握手丢包的握手过程抓包截图。</p>
<p>Image</p>
<p>通过该图可以看到，客户端在 1 s 以后进行了第一次握手重试。重试仍然没有响应，那么接下来依次又分别在 3 s、7 s 15 s，31 s，63 s 等时间共重试了 6 次（我的 tcp_syn_retries 当时设置是 6）。</p>
<p>假如我们服务器上在第一次握手的时候出现了半/全连接队列溢出导致的丢包，那么我们的接口响应时间将至少是 1 s 以上（在某些老版本的内核上，SYN 第一次的重试就需要等 3 秒），如果连续两三次握手都失败，那 7，8 秒就出去了。你想想这对用户是不是影响很大。</p>
<h1 id="三、第三次握手丢包"><a href="#三、第三次握手丢包" class="headerlink" title="三、第三次握手丢包"></a>三、第三次握手丢包</h1><p>客户端在收到服务器的 synack 响应的时候，就认为连接建立成功了，然后会将自己的连接状态设置为 ESTABLISHED，发出第三次握手请求。但服务器在第三次握手的时候，还有可能会有意外发生。</p>
<figure class="highlight plain"><figcaption><span>net/ipv4/tcp_ipv4.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct sock *tcp_v4_syn_recv_sock(struct sock *sk, ...)</span><br><span class="line">&#123;    </span><br><span class="line">    //判断接收队列是不是满了</span><br><span class="line">    if (sk_acceptq_is_full(sk))</span><br><span class="line">        goto exit_overflow;</span><br><span class="line">    ...</span><br><span class="line">exit_overflow:</span><br><span class="line"> NET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENOVERFLOWS);</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上述代码可以看出，第三次握手时，如果服务器全连接队列满了，来自客户端的 ack 握手包又被直接丢弃了。</p>
<p>想想也很好理解，三次握手完的请求是要放在全连接队列里的。但是假如全连接队列满了，仍然三次握手也不会成功。</p>
<p>不过有意思的是，第三次握手失败并不是客户端重试，而是由客户端来重发 synack。</p>
<p>我们搞一个实际的 Case 来直接抓包看一下。我专门写了个简单的 Server 只 listen 不 accept，然后找个客户端把它的连接队列消耗光。这时候，再用另一个客户端向它发起请求时的抓包结果。</p>
<p>Image</p>
<p>第一个红框内是第三次握手，其实这个握手请求在服务器端以及被丢弃了。但是这时候客户端并不知情，它一直傻傻地以为三次握手已经妥了呢。不过还好，这时在服务器的半连接队列中仍然记录着第一次握手时存的握手请求。</p>
<p>服务器等到半连接定时器到时后，向客户端重新发起 synack ，客户端收到后再重新回复第三次握手 ack。如果这期间服务器端全连接队列一直都是满的，那么服务器重试 5 次（受内核参数 net.ipv4.tcp_synack_retries 控制）后就放弃了。</p>
<p>在这种情况下大家还要注意另外一个问题。在实践中，客户端往往是以为连接建立成功就会开始发送数据，其实这时候连接还没有真的建立起来。他发出去的数据，包括重试都将全部被服务器无视。直到连接真正建立成功后才行。</p>
<p>Image</p>
<h1 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h1><p>衡量工程师是否优秀的标准之一就是看他能否有能力定位和处理线上发生的各种问题。连看似简单的一个 TCP 三次握手，工程实践中可能会有各种意外发生。如果对握手理解不深，那么很有可能无法处理线上出现的各种故障。</p>
<p>今天的文章主要是描述了端口不足、半连接队列满、全连接队列满时的情况，</p>
<p>当端口不充足的时候，会导致 connect 系统调用的时候过多地执行自旋锁等待与 Hash 查找，会引起 CPU 开销上涨。严重情况下会耗光 CPU，影响用户业务逻辑的执行。出现这种问题处理起来方法有这么几个。</p>
<p>通过调整 ip_local_port_range 来尽量加大端口范围<br>尽量复用连接，使用长连接来削减频繁的握手处理<br>第三个有用，但是不太推荐的是开启 tcp_tw_reuse 和 tcp_tw_recycle<br>服务器端在第一次握手时可能会丢包， 在如下两种情况下会发生。</p>
<p>半连接队列满，且 tcp_syncookies 为 0<br>全连接队列满，且有未完成的半连接请求<br>在这两种情况下，客户端视角来看和网络断了没有区别，就是发出去的 SYN 包没有任何反馈，然后等待定时器到时后重传握手请求。第一次重传时间是 1 s ，接下来的等待间隔是翻倍地增长，2 s，4 s，8 s …。总的重传次数由 net.ipv4.tcp_syn_retries 内核参数影响（注意我的用词是影响，而不是决定）。</p>
<p>服务器在第三次握手时也可能会出问题，如果全连接队列满，仍将会发生丢包。不过第三次握手失败时，只有服务器端知道（客户端误以为连接已经建立成功了）。服务器根据半连接队列里的握手信息发起 synack 重试，重试次数由 net.ipv4.tcp_synack_retries 控制。</p>
<p>一旦你的线上出现了上面这些连接队列溢出导致的问题，你的服务将会受到比较严重的影响。即使第一次重试就能够成功，那你的接口响应耗时将直接上涨到 1 s（老版本上是 3 s）。如果重试上两三次都没有成功，Nginx 很有可能直接就报访问超时失败了。</p>
<p>正因为握手重试对我们服务影响很大，所以能深刻理解三次握手中的这些异常情况很有必要。再说说如果出现了丢包的问题，我们该如何应对。</p>
<h1 id="方法1，打开-syncookie"><a href="#方法1，打开-syncookie" class="headerlink" title="方法1，打开 syncookie"></a>方法1，打开 syncookie</h1><p>在现代的 Linux 版本里，我们可以通过打开 tcp_syncookies 来防止过多的请求打满半连接队列包括 SYN Flood 攻击，来解决服务器因为半连接队列满而发生的丢包。</p>
<h1 id="方法2，加大连接队列长度"><a href="#方法2，加大连接队列长度" class="headerlink" title="方法2，加大连接队列长度"></a>方法2，加大连接队列长度</h1><p>在《为什么服务端程序都需要先 listen 一下？》中，我们讨论过全连接队列的长度是 min(backlog, net.core.somaxconn)半连接队列长度是。半连接队列长度有点小复杂，是 min(backlog, somaxconn, tcp_max_syn_backlog) + 1 再上取整到 2 的幂次，但最小不能小于16。</p>
<p>如果需要加大全/半连接队列长度，请调节以上的一个或多个参数来达到目的。只要队列长度合适，就能很大程序降低握手异常概率的发生。</p>
<h1 id="方法3，尽快地-accept"><a href="#方法3，尽快地-accept" class="headerlink" title="方法3，尽快地 accept"></a>方法3，尽快地 accept</h1><p>另外这个虽然一般不会成为问题，但也要注意一下。你的应用程序应该尽快在握手成功之后通过 accept 把新连接取走。不要忙于处理其它业务逻辑而导致全连接队列塞满了。</p>
<h1 id="方法4，尽量减少-TCP-连接的次数"><a href="#方法4，尽量减少-TCP-连接的次数" class="headerlink" title="方法4，尽量减少 TCP 连接的次数"></a>方法4，尽量减少 TCP 连接的次数</h1><p>如果上述方法都未能根治你的问题，那说明你的服务器上 TCP 连接请求太、太过于频繁了。这个时候你应该思考下是否可以用长连接代替短连接，减少过于频繁的三次握手。这个方法不但能解决握手出问题的可能，而且还顺带砍掉了三次握手的各种内存、CPU、时间上的开销，对提升性能也有较大帮助。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://chenfengying.github.io/2021/08/10/深入解析常见三次握手异常/" data-id="cm780tvp8001jc0vlt6b71mwq" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-登录接口的安全思考" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/08/09/登录接口的安全思考/" class="article-date">
  <time datetime="2021-08-09T16:48:37.000Z" itemprop="datePublished">2021-08-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Internet-Basic/">Internet Basic</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/08/09/登录接口的安全思考/">登录接口的安全思考</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>前言</p>
<p>大家学写程序时，第一行代码都是hello world。但是当你开始学习WEB后台技术时，很多人的第一个功能就是写的登录 （小声：别人我不知道，反正我是）。<br>但是我在和很多工作经验较短的同学面试或沟通的时候，发现很多同学虽然都有在简历上写：负责项目的登录/注册功能模块的开发和设计工作，但是都只是简单的实现了功能逻辑，在安全方面并没有考虑太多。<br>这篇文章主要是和大家聊一聊，在设计一个登录接口时，不仅仅是功能上的实现，在安全方面，我们还需要考虑哪些地方。<br>安全风险<br>暴力破解！<br>只要网站是暴露在公网的，那么很大概率上会被人盯上，尝试爆破这种简单且有效的方式：<br>通过各种方式获得了网站的用户名之后，通过编写程序来遍历所有可能的密码，直至找到正确的密码为止<br>伪代码如下：</p>
<h1 id="密码字典"><a href="#密码字典" class="headerlink" title="密码字典"></a>密码字典</h1><p>password_dict = []  </p>
<h1 id="登录接口"><a href="#登录接口" class="headerlink" title="登录接口"></a>登录接口</h1><p>login_url = ‘’<br>def attack(username):<br> for password in password_dict:<br>     data = {‘username’: username, ‘password’: password}<br>       content = requests.post(login_url, data).content.decode(‘utf-8’)<br>       if ‘login success’ in content:<br>           print(‘got it! password is : %s’ % password)<br>那么这种情况，我们要怎么防范呢？<br>验证码<br>有聪明的同学就想到了，我可以在它密码错误达到一定次数时，增加验证码校验！比如我们设置，当用户密码错误达到3次之后，则需要用户输入图片验证码才可以继续登录操作：<br>伪代码如下：<br>fail_count = get_from_redis(fail_username)<br>if fail_count &gt;= 3:<br> if captcha is None:<br>  return error(‘需要验证码’)<br>    check_captcha(captcha)<br>success = do_login(username, password)<br>if not success:<br> set_redis(fail_username, fail_count + 1)<br>伪代码未考虑并发，实际开发可以考虑加锁。<br>这样确实可以过滤掉一些非法的攻击，但是以目前的OCR技术来说的话，普通的图片验证码真的很难做到有效的防止机器人（我们就在这个上面吃过大亏）。<br>当然，我们也可以花钱购买类似于三方公司提供的滑动验证等验证方案，但是也并不是100%的安全，一样可以被破解（惨痛教训）。<br>登录限制<br>那这时候又有同学说了，那我可以直接限制非正常用户的登录操作，当它密码错误达到一定次数时，直接拒绝用户的登录，隔一段时间再恢复。比如我们设置某个账号在登录时错误次数达到10次时，则5分钟内拒绝该账号的所有登录操作。<br>伪代码如下：<br>fail_count = get_from_redis(fail_username)<br>locked = get_from_redis(lock_username)  </p>
<p>if locked:<br> return error(‘拒绝登录’)<br>if fail_count &gt;= 3:<br> if captcha is None:<br>  return error(‘需要验证码’)<br>    check_captcha(captcha)<br>success = do_login(username, password)<br>if not success:<br> set_redis(fail_username, fail_count + 1)<br>    if fail_count + 1 &gt;= 10:  </p>
<pre><code># 失败超过10次，设置锁定标记  
set_redis(lock_username, true, 300s)  
</code></pre><p>umm，这样确实可以解决用户密码被爆破的问题。但是，这样会带来另一个风险：攻击者虽然不能获取到网站的用户信息，但是它可以让我们网站所有的用户都无法登录！<br>攻击者只需要无限循环遍历所有的用户名（即使没有，随机也行）进行登录，那么这些用户会永远处于锁定状态，导致正常的用户无法登录网站！<br>IP限制<br>那既然直接针对用户名不行的话，我们可以针对IP来处理，直接把攻击者的IP封了不就万事大吉了嘛。我们可以设定某个IP下调用登录接口错误次数达到一定时，则禁止该IP进行登录操作。<br>伪代码如下：<br>ip = request[‘IP’]<br>fail_count = get_from_redis(fail_ip)<br>if fail_count &gt; 10:<br> return error(‘拒绝登录’)  </p>
<h1 id="其它逻辑"><a href="#其它逻辑" class="headerlink" title="其它逻辑"></a>其它逻辑</h1><h1 id="do-something"><a href="#do-something" class="headerlink" title="do something()"></a>do something()</h1><p>success = do_login(username, password)<br>if not success:<br> set_redis(fail_ip, true, 300s)<br>这样也可以一定程度上解决问题，事实上有很多的限流操作都是针对IP进行的，比如niginx的限流模块就可以限制一个IP在单位时间内的访问次数。<br>但是这里还是存在问题：<br>比如现在很多学校、公司都是使用同一个出口IP，如果直接按IP限制，可能会误杀其它正常的用户</p>
<p>现在这么多VPN，攻击者完全可以在IP被封后切换VPN来攻击</p>
<p>手机验证<br>那难道就没有一个比较好的方式来防范吗？　当然有。　我们可以看到近些年来，几乎所有的应用都会让用户绑定手机，一个是国家的实名制政策要求，第二个是手机基本上和身份证一样，基本上可以代表一个人的身份标识了。所以很多安全操作都是基于手机验证来进行的，登录也可以。<br>当用户输入密码次数大于3次时，要求用户输入验证码（最好使用滑动验证）</p>
<p>当用户输入密码次数大于10次时，弹出手机验证，需要用户使用手机验证码和密码双重认证进行登录</p>
<p>手机验证码防刷就是另一个问题了，这里不展开，以后再有时间再聊聊我们在验证码防刷方面做了哪些工作。<br>伪代码如下：<br>fail_count = get_from_redis(fail_username)  </p>
<p>if fail_count &gt; 3:<br> if captcha is None:<br>  return error(‘需要验证码’)<br>    check_captcha(captcha)   </p>
<p>if fail_count &gt; 10:  </p>
<h1 id="大于10次，使用验证码和密码登录"><a href="#大于10次，使用验证码和密码登录" class="headerlink" title="大于10次，使用验证码和密码登录"></a>大于10次，使用验证码和密码登录</h1><p> if dynamic_code is None:<br>     return error(‘请输入手机验证码’)<br>    if not validate_dynamic_code(username, dynamic_code):<br>     delete_dynamic_code(username)<br>     return error(‘手机验证码错误’)  </p>
<p> success = do_login(username, password, dynamic_code)  </p>
<p> if not success:<br>     set_redis(fail_username, fail_count + 1)<br>我们结合了上面说的几种方式的同时，加上了手机验证码的验证模式，基本上可以阻止相当多的一部分恶意攻击者。但是没有系统是绝对安全的，我们只能够尽可能的增加攻击者的攻击成本。大家可以根据自己网站的实际情况来选择合适的策略。<br>中间人攻击？<br>什么是中间人攻击<br>中间人攻击(man-in-the-middle attack, abbreviated to MITM)，简单一点来说就是，A和B在通讯过程中，攻击者通过嗅探、拦截等方式获取或修改A和B的通讯内容。<br>举个栗子：小白给小黄发快递，途中要经过快递点A，小黑就躲在快递点A，或者干脆自己开一个快递点B来冒充快递点A。然后偷偷的拆了小白给小黄的快递，看看里面有啥东西。甚至可以把小白的快递给留下来，自己再打包一个一毛一样的箱子发给小黄。<br>那在登录过程中，如果攻击者在嗅探到了从客户端发往服务端的登录请求，就可以很轻易的获取到用户的用户名和密码。<br>HTTPS<br>防范中间人攻击最简单也是最有效的一个操作，更换HTTPS，把网站中所有的HTTP请求修改为强制使用HTTPS。<br>为什么HTTPS可以防范中间人攻击？<br>HTTPS实际上就是在HTTP和TCP协议中间加入了SSL/TLS协议，用于保障数据的安全传输。相比于HTTP，HTTPS主要有以下几个特点：<br>内容加密</p>
<p>数据完整性</p>
<p>身份验证</p>
<p>具体的HTTPS原理这里就不再扩展了，大家可以自行Google<br>加密传输<br>在HTTPS之外，我们还可以手动对敏感数据进行加密传输：<br>用户名可以在客户端使用非对称加密，在服务端解密</p>
<p>密码可以在客户端进行MD5之后传输，防止暴露密码明文</p>
<p>其它<br>除了上面我们聊的这些以外，其实还有很多其它的工作可以考虑，比如：<br>操作日志，用户的每次登录和敏感操作都需要记录日志（包括IP、设备等）</p>
<p>异常操作或登录提醒，有了上面的操作日志，那我们就可以基于日志做风险提醒，比如用户在进行非常登录地登录、修改密码、登录异常时，可以短信提醒用户</p>
<p>拒绝弱密码 注册或修改密码时，不允许用户设置弱密码</p>
<p>防止用户名被遍历 有些网站在注册时，在输入完用户名之后，会提示用户名是否存在。这样会存在网站的所有用户名被泄露的风险（遍历该接口即可），需要在交互或逻辑上做限制</p>
<p>…</p>
<p>后记<br>现在国家不断的出台各种法律，对用户的数据越来越看重。作为开发者，我们也需要在保护用户数据和用户隐私方面做更多的工作。后面我也会和大家聊一聊，我们在数据安全方面，做了哪些工作，希望可以给到大家一点点帮助。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://chenfengying.github.io/2021/08/09/登录接口的安全思考/" data-id="cm780tvpj001oc0vl657q9pic" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-RESTful-API-中Http-状态码的定义" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/08/04/RESTful-API-中Http-状态码的定义/" class="article-date">
  <time datetime="2021-08-04T11:52:38.000Z" itemprop="datePublished">2021-08-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Internet-Basic/">Internet Basic</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/08/04/RESTful-API-中Http-状态码的定义/">RESTful API 中Http 状态码的定义</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>（题外话：RESTful 中 f 不应当大写）首先，针对题主的问题通用解法：对于请求不合理（比如类型错误）导致没有资源应当返回 4XX。<br>如果是因为请求的某些条件组合后没有符合的资源，那么返回 404。最近正好使用了一会儿 Koa ，<br>在这说一下自己对各个 请求码的见解和使用场景，懒人直接看 200、400、401、403、404、500 就可以了。<br>其中 2XX/3XX 其实都是请求成功，但是结果不同。4XX 是请求出错，5XX 是服务器处理出现错误。</p>
<p>200这个最容易理解，就是正确的请求返回正确的结果，如果不想细分正确的请求结果都可以直接返回200。<br>201表示资源被正确的创建。比如说，我们 POST 用户名、密码正确创建了一个用户就可以返回 201。<br>202请求是正确的，但是结果正在处理中，没法返回对应的结果。比如说，我们请求一个需要大量计算的结果，但是并没有计算结束时，可以返回这个，这时候客户端可以通过轮询等机制继续请求。<br>203请求的代理服务器修改了源服务器返回的 200 中的内容，一般用不到。比如说，我们通过代理服务器向服务器 A 请求用户信息，服务器 A 正常响应，但代理服务器命中了缓存并返回了自己的缓存内容，这时候它返回 203 告诉我们这部分信息不一定是最新的，我们可以自行判断并处理。<br>204请求正确，但是没有需要返回的内容。比如说，我们请求删除某个用户，删除成功可以返回 204。<br>205类似 204，但是要求请求者重置视图，一般也用不到。比如说，我们请求删除某个用户，服务器返回 205 的话，我们就刷新现在的用户列表。<br>206请求成功，但根据请求头只返回了部分内容。比如说，我们下载一部片，共有 10 部分，我们把请求也分成了 10 次（防止一次请求过大），这时候服务器就可以返回 206 并在其头部告诉我们这是哪一部分，然后再根据这个信息进行拼装。<br>300请求成功，但结果有多种选择。比如说，我们下载一部片，服务器有 avi、mp4 等格式，这时候可以返回 300，并在 body 里告知有哪些格式，然后用户可以根据这些格式再次请求。<br>301请求成功，但是资源被永久转移。比如说，我们要下载葫芦娃，但是由于旧的存储服务商涨价了，现在要使用新的存储服务了，要去新地址下载，这时候可以返回 301，并在 header 的 Location 中告知新的地址，以后也应当到这个地址下载。<br>302请求成功，但是资源被临时转移了。和 301 不同的是，除非是 HEAD 请求，否则新地址的信息应当在 body 中返回，并且资源只是临时转移，以后不应当通过新地址来下载。<br>303类似 302，但要求使用 GET 来访问新的地址来获取资源。<br>304请求的资源并没有被修改过。比如说，我们发送请求想看看 5.20 后的情侣信息，服务器查询没有新的情侣信息产生，这时候可以返回 304，然后客户端可以继续用旧的数据。<br>305请求的资源必须通过代理访问。比如说，我们想请求服务器 A 上新的 iPhone 的信息，但是需要通过代理服务器才能访问，如果直接请求了服务器 A，没有经过代理服务器，这时候服务器 A 就可以返回 305 从而告诉我们应当访问代理服务器。<br>306不用了。<br>307类似 302，但要求使用原有的请求方式来通过新地址获取资源。<br>308类似 301，但要求使用原有的请求方式来通过新地址获取资源。<br>400请求出现错误，比如请求头不对等，所有不想明确区分的客户端请求出错都可以返回 400。<br>401没有提供认证信息。比如说，请求的时候没有带上 Token 等。<br>402为将来的需要所保留的状态码。<br>403请求的资源不允许访问。比如说，你使用普通用户的 Token 去请求管理员才能访问的资源。<br>404请求的内容不存在。<br>405请求的方法不允许使用。比如说，服务器只实现了 PATCH 了局部更新资源，并没有实现 PUT 来替换资源，而我们使用了 PUT，这时候服务器可以返回 405 来告知并没有实现对 PUT 的相关处理。<br>406请求的资源并不符合要求。比如说，我们 header 里请求 JSON 格式的数据，但是服务器只有 XML 格式的数据，这时候可以返回 406 告知。<br>407类似 401，但是要求必须去同代理服务器进行认证。<br>408客户端请求超时。我们想 POST 创建一个用户，虽然建立了连接，但是网络不好，服务器在规定时间内没有得到我们的请求信息，这时候服务器可以返回 408 告诉我们超时了。然后我们可以重新发送请求。<br>409请求冲突。比如说，服务器要求不同用户不能重名，服务器已经有了一个名叫小伟的用户，这时候我们又想创建一个名叫小伟的用户，服务器可以返回 409，告诉我们冲突了，也可以在 body 中明确告知是什么冲突了。<br>410请求资源曾经存在，但现在不存在了。比如说，我们下载葫芦娃，但是因为版权被删了，下载不了了，这时候服务器返回 410，告诉我们洗洗早点睡。<br>411没有提供请求资源的长度。比如说，我们下载葫芦娃，服务器只允许我们分部分下载，我们如果不告诉服务器我们要下载哪部分，服务器就返回 411 警告我们。<br>412请求的资源不符合请求头中的 IF-* 的某些条件。比如说，我们下载葫芦娃，然后在请求头告知服务器要 5.20 后更新过的，服务器没有，于是返回了 412。<br>413请求体过大。比如说，服务器要求上传文件不能超过 5M，但是我们 POST 了 10M，这时候就返回 413。<br>414请求的 URI 太长了。比如说，我们提供了太多的 Query 参数，以至于超过了服务器的限制，这时候可以返回 414。<br>415不支持的媒体类型。比如说，我们上传了一张七娃的 GIF 动图，而服务器只允许你上传 PNG 图片，这时候就返回 415。<br>416请求的区间无效。比如说，我们分部分下载时请求葫芦娃的 10 分钟到 12 分钟的内容，但是这部葫芦娃只有 1 分钟的内容，这时候就返回 416。<br>417预期错误。指服务器没法满足我们在请求头里的 Expect 相关的信息。<br>418我是个茶壶。这是一个愚人节的玩笑，这个状态码就是用来搞笑的。<br>500服务器错误。没法明确定义的服务器错误都可以返回这个。<br>501请求还没有被实现。比如说，我们请求一个接口来自动拒绝项目经理的要求，但是这个接口只是美好的想象，并没有被实现，这时候可以返回 501。<br>502网关错误。比如说，我们向服务器 A 请求下载葫芦娃，但是 A 其实只是一个代理服务器，他得向 B 请求葫芦娃，但是不知道为啥 B 不理他或者给他错误，这时候哦可以 A 返回 502 用来表示 B 这家伙傲娇了。<br>503服务暂时不可用。比如说，服务器正好在更新代码重启。<br>504类似 502，但是这时候是 B 不理 A，超时了 。<br>505请求的 HTTP 版本不支持。比如说，现在强行根据 HTTP 1000 来请求。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://chenfengying.github.io/2021/08/04/RESTful-API-中Http-状态码的定义/" data-id="cm780tvnq000bc0vlmr9jlusm" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-什么是Nginx以及使用场景" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/07/27/什么是Nginx以及使用场景/" class="article-date">
  <time datetime="2021-07-27T15:25:05.000Z" itemprop="datePublished">2021-07-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Nginx/">Nginx</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/07/27/什么是Nginx以及使用场景/">什么是Nginx以及使用场景</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>一、HTTP服务器</p>
<p>Nginx本身也是一个静态资源的服务器，当只有静态资源的时候，就可以使用Nginx来做服务器，如果一个网站只是静态页面的话，那么就可以通过这种方式来实现部署。</p>
<p>1、 首先在文档根目录Docroot(/usr/local/var/www)下创建html目录, 然后在html中放一个test.html;</p>
<p>图片<br>2、 配置nginx.conf中的server</p>
<p>user mengday staff;</p>
<p>http {<br>    server {<br>        listen       80;<br>        server_name  localhost;<br>        client_max_body_size 1024M;</p>
<pre><code>    # 默认location
    location / {
        root   /usr/local/var/www/html;
        index  index.html index.htm;
    }
}
</code></pre><p>}<br>3、访问测试</p>
<p><a href="http://localhost/" target="_blank" rel="noopener">http://localhost/</a> 指向/usr/local/var/www/index.html, index.html是安装nginx自带的html<br><a href="http://localhost/test.html" target="_blank" rel="noopener">http://localhost/test.html</a> 指向/usr/local/var/www/html/test.html<br>注意：如果访问图片出现403 Forbidden错误，可能是因为nginx.conf 的第一行user配置不对，默认是#user nobody;是注释的，linux下改成user root; macos下改成user 用户名 所在组; 然后重新加载配置文件或者重启，再试一下就可以了， 用户名可以通过who am i 命令来查看。</p>
<p>4、指令简介</p>
<p>server : 用于定义服务，http中可以有多个server块<br>listen : 指定服务器侦听请求的IP地址和端口，如果省略地址，服务器将侦听所有地址，如果省略端口，则使用标准端口<br>server_name : 服务名称，用于配置域名<br>location : 用于配置映射路径uri对应的配置，一个server中可以有多个location, location后面跟一个uri,可以是一个正则表达式, / 表示匹配任意路径, 当客户端访问的路径满足这个uri时就会执行location块里面的代码<br>root : 根路径，当访问<a href="http://localhost/test.html，“/test.html”会匹配到”/”uri" target="_blank" rel="noopener">http://localhost/test.html，“/test.html”会匹配到”/”uri</a>, 找到root为/usr/local/var/www/html，用户访问的资源物理地址=root + uri = /usr/local/var/www/html + /test.html=/usr/local/var/www/html/test.html<br>index : 设置首页，当只访问server_name时后面不跟任何路径是不走root直接走index指令的；如果访问路径中没有指定具体的文件，则返回index设置的资源，如果访问<a href="http://localhost/html/" target="_blank" rel="noopener">http://localhost/html/</a> 则默认返回index.html<br>5、location uri正则表达式</p>
<p>. ：匹配除换行符以外的任意字符<br>? ：重复0次或1次</p>
<ul>
<li>：重复1次或更多次</li>
</ul>
<ul>
<li>：重复0次或更多次<br>\d ：匹配数字<br>^ ：匹配字符串的开始<br>$ ：匹配字符串的结束<br>{n} ：重复n次<br>{n,} ：重复n次或更多次<br>[c] ：匹配单个字符c<br>[a-z] ：匹配a-z小写字母的任意一个<br>(a|b|c) : 属线表示匹配任意一种情况，每种情况使用竖线分隔，一般使用小括号括括住，匹配符合a字符 或是b字符 或是c字符的字符串<br>\ 反斜杠：用于转义特殊字符<br>小括号()之间匹配的内容，可以在后面通过$1来引用，$2表示的是前面第二个()里的内容。正则里面容易让人困惑的是\转义特殊字符。</li>
</ul>
<p>二、静态服务器<br>在公司中经常会遇到静态服务器，通常会提供一个上传的功能，其他应用如果需要静态资源就从该静态服务器中获取。</p>
<p>1、在/usr/local/var/www 下分别创建images和img目录，分别在每个目录下放一张test.jpg</p>
<p>图片<br>http {<br>    server {<br>        listen       80;<br>        server_name  localhost;</p>
<pre><code>    set $doc_root /usr/local/var/www;

    # 默认location
    location / {
        root   /usr/local/var/www/html;
        index  index.html index.htm;
    }

    location ^~ /images/ {
        root $doc_root;
   }

   location ~* \.(gif|jpg|jpeg|png|bmp|ico|swf|css|js)$ {
       root $doc_root/img;
   }
}
</code></pre><p>}<br>自定义变量使用set指令，语法 set 变量名值;引用使用变量名值;引用使用变量名; 这里自定义了doc_root变量。</p>
<p>静态服务器location的映射一般有两种方式：</p>
<p>使用路径，如 /images/ 一般图片都会放在某个图片目录下，<br>使用后缀，如 .jpg、.png 等后缀匹配模式<br>访问<a href="http://localhost/test.jpg" target="_blank" rel="noopener">http://localhost/test.jpg</a> 会映射到 $doc_root/img</p>
<p>访问<a href="http://localhost/images/test.jpg" target="_blank" rel="noopener">http://localhost/images/test.jpg</a> 当同一个路径满足多个location时，优先匹配优先级高的location，由于^~ 的优先级大于 ~, 所以会走/images/对应的location</p>
<p>常见的location路径映射路径有以下几种：</p>
<p>=       进行普通字符精确匹配。也就是完全匹配。<br>^~         前缀匹配。如果匹配成功，则不再匹配其他location。<br>~      表示执行一个正则匹配，区分大小写<br>~*         表示执行一个正则匹配，不区分大小写<br>/xxx/   常规字符串路径匹配<br>/       通用匹配，任何请求都会匹配到<br>location优先级<br>当一个路径匹配多个location时究竟哪个location能匹配到时有优先级顺序的，而优先级的顺序于location值的表达式类型有关，和在配置文件中的先后顺序无关。相同类型的表达式，字符串长的会优先匹配。推荐：Java面试题大全</p>
<p>以下是按优先级排列说明：</p>
<p>等号类型（=）的优先级最高。一旦匹配成功，则不再查找其他匹配项，停止搜索。<br>^~类型表达式，不属于正则表达式。一旦匹配成功，则不再查找其他匹配项，停止搜索。<br>正则表达式类型（~ ~*）的优先级次之。如果有多个location的正则能匹配的话，则使用正则表达式最长的那个。<br>常规字符串匹配类型。按前缀匹配。<br>/ 通用匹配，如果没有匹配到，就匹配通用的<br>优先级搜索问题：不同类型的location映射决定是否继续向下搜索</p>
<p>等号类型、^~类型：一旦匹配上就停止搜索了，不会再匹配其他location了<br>正则表达式类型(~ ~*）,常规字符串匹配类型/xxx/ : 匹配到之后，还会继续搜索其他其它location，直到找到优先级最高的，或者找到第一种情况而停止搜索<br>location优先级从高到底：</p>
<p>(location =) &gt; (location 完整路径) &gt; (location ^~ 路径) &gt; (location ~,~* 正则顺序) &gt; (location 部分起始路径) &gt; (/)</p>
<p>location = / {</p>
<pre><code># 精确匹配/，主机名后面不能带任何字符串 /
[ configuration A ]
</code></pre><p>}<br>location / {</p>
<pre><code># 匹配所有以 / 开头的请求。
# 但是如果有更长的同类型的表达式，则选择更长的表达式。
# 如果有正则表达式可以匹配，则优先匹配正则表达式。
[ configuration B ]
</code></pre><p>}<br>location /documents/ {</p>
<pre><code># 匹配所有以 /documents/ 开头的请求，匹配符合以后，还要继续往下搜索。
# 但是如果有更长的同类型的表达式，则选择更长的表达式。
# 如果有正则表达式可以匹配，则优先匹配正则表达式。
[ configuration C ]
</code></pre><p>}<br>location ^~ /images/ {</p>
<pre><code># 匹配所有以 /images/ 开头的表达式，如果匹配成功，则停止匹配查找，停止搜索。
# 所以，即便有符合的正则表达式location，也不会被使用
[ configuration D ]
</code></pre><p>}</p>
<p>location ~* .(gif|jpg|jpeg)$ {</p>
<pre><code># 匹配所有以 gif jpg jpeg结尾的请求。
# 但是 以 /images/开头的请求，将使用 Configuration D，D具有更高的优先级
[ configuration E ]
</code></pre><p>}</p>
<p>location /images/ {</p>
<pre><code># 字符匹配到 /images/，还会继续往下搜索
[ configuration F ]
</code></pre><p>}</p>
<p>location = /test.htm {<br>    root   /usr/local/var/www/htm;<br>    index  index.htm;<br>}<br>注意：location的优先级与location配置的位置无关</p>
<p>三、反向代理<br>反向代理应该是Nginx使用最多的功能了，反向代理(Reverse Proxy)方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。</p>
<p>简单来说就是真实的服务器不能直接被外部网络访问，所以需要一台代理服务器，而代理服务器能被外部网络访问的同时又跟真实服务器在同一个网络环境，当然也可能是同一台服务器，端口不同而已。</p>
<p>反向代理通过proxy_pass指令来实现。</p>
<p>启动一个Java Web项目，端口号为8081</p>
<p>server {<br>    listen       80;<br>    server_name  localhost;</p>
<pre><code>location / {
    proxy_pass http://localhost:8081;
    proxy_set_header Host $host:$server_port;
    # 设置用户ip地址
     proxy_set_header X-Forwarded-For $remote_addr;
     # 当请求服务器出错去寻找其他服务器
     proxy_next_upstream error timeout invalid_header http_500 http_502 http_503; 
}
</code></pre><p>}<br>当我们访问localhost的时候，就相当于访问 localhost:8081了</p>
<p>四、负载均衡<br>负载均衡也是Nginx常用的一个功能，负载均衡其意思就是分摊到多个操作单元上进行执行，例如Web服务器、FTP服务器、企业关键应用服务器和其它关键任务服务器等，从而共同完成工作任务。</p>
<p>简单而言就是当有2台或以上服务器时，根据规则随机的将请求分发到指定的服务器上处理，负载均衡配置一般都需要同时配置反向代理，通过反向代理跳转到负载均衡。而Nginx目前支持自带3种负载均衡策略，还有2种常用的第三方策略。</p>
<p>负载均衡通过upstream指令来实现。推荐：Java面试题大全</p>
<ol>
<li>RR(round robin :轮询 默认)<br>每个请求按时间顺序逐一分配到不同的后端服务器，也就是说第一次请求分配到第一台服务器上，第二次请求分配到第二台服务器上，如果只有两台服务器，第三次请求继续分配到第一台上，这样循环轮询下去，也就是服务器接收请求的比例是 1:1， 如果后端服务器down掉，能自动剔除。轮询是默认配置，不需要太多的配置</li>
</ol>
<p>同一个项目分别使用8081和8082端口启动项目</p>
<p>upstream web_servers {<br>   server localhost:8081;<br>   server localhost:8082;<br>}</p>
<p>server {<br>    listen       80;<br>    server_name  localhost;</p>
<pre><code>#access_log  logs/host.access.log  main;


location / {
    proxy_pass http://web_servers;
    # 必须指定Header Host
    proxy_set_header Host $host:$server_port;
}
</code></pre><p> }<br>访问地址仍然可以获得响应 <a href="http://localhost/api/user/login?username=zhangsan&amp;password=111111" target="_blank" rel="noopener">http://localhost/api/user/login?username=zhangsan&amp;password=111111</a> ，这种方式是轮询的</p>
<ol start="2">
<li>权重<br>指定轮询几率，weight和访问比率成正比, 也就是服务器接收请求的比例就是各自配置的weight的比例，用于后端服务器性能不均的情况,比如服务器性能差点就少接收点请求，服务器性能好点就多处理点请求。</li>
</ol>
<p>upstream test {<br>    server localhost:8081 weight=1;<br>    server localhost:8082 weight=3;<br>    server localhost:8083 weight=4 backup;<br>}<br>示例是4次请求只有一次被分配到8081上，其他3次分配到8082上。backup是指热备，只有当8081和8082都宕机的情况下才走8083</p>
<ol start="3">
<li>ip_hash<br>上面的2种方式都有一个问题，那就是下一个请求来的时候请求可能分发到另外一个服务器，当我们的程序不是无状态的时候(采用了session保存数据)，这时候就有一个很大的很问题了，比如把登录信息保存到了session中，那么跳转到另外一台服务器的时候就需要重新登录了，所以很多时候我们需要一个客户只访问一个服务器，那么就需要用iphash了，iphash的每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。</li>
</ol>
<p>upstream test {<br>    ip_hash;<br>    server localhost:8080;<br>    server localhost:8081;<br>}</p>
<ol start="4">
<li>fair(第三方)<br>按后端服务器的响应时间来分配请求，响应时间短的优先分配。这个配置是为了更快的给用户响应</li>
</ol>
<p>upstream backend {<br>    fair;<br>    server localhost:8080;<br>    server localhost:8081;<br>}</p>
<ol start="5">
<li>url_hash(第三方)<br>按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。在upstream中加入hash语句，server语句中不能写入weight等其他的参数，hash_method是使用的hash算法</li>
</ol>
<p>upstream backend {<br>    hash $request_uri;<br>    hash_method crc32;<br>    server localhost:8080;<br>    server localhost:8081;<br>}<br>以上5种负载均衡各自适用不同情况下使用，所以可以根据实际情况选择使用哪种策略模式,不过fair和url_hash需要安装第三方模块才能使用。</p>
<p>五、动静分离<br>动静分离是让动态网站里的动态网页根据一定规则把不变的资源和经常变的资源区分开来，动静资源做好了拆分以后，我们就可以根据静态资源的特点将其做缓存操作，这就是网站静态化处理的核心思路。</p>
<p>upstream web_servers {<br>       server localhost:8081;<br>       server localhost:8082;<br>}</p>
<p>server {<br>    listen       80;<br>    server_name  localhost;</p>
<pre><code>set $doc_root /usr/local/var/www;

location ~* \.(gif|jpg|jpeg|png|bmp|ico|swf|css|js)$ {
   root $doc_root/img;
}

location / {
    proxy_pass http://web_servers;
    # 必须指定Header Host
    proxy_set_header Host $host:$server_port;
}

error_page 500 502 503 504  /50x.html;  
location = /50x.html {  
    root $doc_root;
}
</code></pre><p> }<br>六、其他<br>1.return指令<br>返回http状态码 和 可选的第二个参数可以是重定向的URL</p>
<p>location /permanently/moved/url {<br>    return 301 <a href="http://www.example.com/moved/here" target="_blank" rel="noopener">http://www.example.com/moved/here</a>;<br>}</p>
<ol start="2">
<li>rewrite指令<br>重写URI请求 rewrite，通过使用rewrite指令在请求处理期间多次修改请求URI，该指令具有一个可选参数和两个必需参数。</li>
</ol>
<p>第一个(必需)参数是请求URI必须匹配的正则表达式。</p>
<p>第二个参数是用于替换匹配URI的URI。</p>
<p>可选的第三个参数是可以停止进一步重写指令的处理或发送重定向(代码301或302)的标志</p>
<p>location /users/ {<br>    rewrite ^/users/(.*)$ /show?user=$1 break;<br>}</p>
<ol start="3">
<li>error_page指令<br>使用error_page指令，您可以配置NGINX返回自定义页面以及错误代码，替换响应中的其他错误代码，或将浏览器重定向到其他URI。在以下示例中，error_page指令指定要返回404页面错误代码的页面(/404.html)。</li>
</ol>
<p>error_page 404 /404.html;</p>
<ol start="4">
<li>日志<br>访问日志：需要开启压缩 gzip on; 否则不生成日志文件，打开log_format、access_log注释</li>
</ol>
<p>log_format  main  ‘$remote_addr - $remote_user [$time_local] “$request” ‘<br>                      ‘$status $body_bytes_sent “$http_referer” ‘<br>                      ‘“$http_user_agent” “$http_x_forwarded_for”‘;</p>
<p>access_log  /usr/local/etc/nginx/logs/host.access.log  main;</p>
<p>gzip  on;</p>
<ol start="5">
<li>deny 指令<h1 id="禁止访问某个目录"><a href="#禁止访问某个目录" class="headerlink" title="禁止访问某个目录"></a>禁止访问某个目录</h1>location ~* .(txt|doc)${<br> root $doc_root;<br> deny all;<br>}   </li>
<li>内置变量<br>nginx的配置文件中可以使用的内置变量以美元符$开始，也有人叫全局变量。其中，部分预定义的变量的值是可以改变的。另外，关注Java知音公众号，回复“后端面试”，送你一份面试题宝典！</li>
</ol>
<p>$args ：#这个变量等于请求行中的参数，同$query_string<br>$content_length ：请求头中的Content-length字段。<br>$content_type ：请求头中的Content-Type字段。<br>$document_root ：当前请求在root指令中指定的值。<br>$host ：请求主机头字段，否则为服务器名称。<br>$http_user_agent ：客户端agent信息<br>$http_cookie ：客户端cookie信息<br>$limit_rate ：这个变量可以限制连接速率。<br>$request_method ：客户端请求的动作，通常为GET或POST。<br>$remote_addr ：客户端的IP地址。<br>$remote_port ：客户端的端口。<br>$remote_user ：已经经过Auth Basic Module验证的用户名。<br>$request_filename ：当前请求的文件路径，由root或alias指令与URI请求生成。<br>$scheme ：HTTP方法（如http，https）。<br>$server_protocol ：请求使用的协议，通常是HTTP/1.0或HTTP/1.1。<br>$server_addr ：服务器地址，在完成一次系统调用后可以确定这个值。<br>$server_name ：服务器名称。<br>$server_port ：请求到达服务器的端口号。<br>$request_uri ：包含请求参数的原始URI，不包含主机名，如：”/foo/bar.php?arg=baz”。<br>$uri ：不带请求参数的当前URI，$uri不包含主机名，如”/foo/bar.html”。<br>$document_uri ：与$uri相同</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://chenfengying.github.io/2021/07/27/什么是Nginx以及使用场景/" data-id="cm780tvoy0019c0vlmasx3zl1" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-正确甄别API-REST-API-RESTFUL-API-和-Web-Service" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/07/26/正确甄别API-REST-API-RESTFUL-API-和-Web-Service/" class="article-date">
  <time datetime="2021-07-26T15:24:32.000Z" itemprop="datePublished">2021-07-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Internet-Basic/">Internet Basic</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/07/26/正确甄别API-REST-API-RESTFUL-API-和-Web-Service/">正确甄别API,REST API,RESTFUL API 和 Web Service</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>看到API你会想起什么？是接口、第三方调用、还是API文档？初看你可能会觉得这太熟悉了，这不是系统开发日常系列吗？但你仔细想一想，你会发现API的概念在你脑海里是如此的模糊。如何你通过搜索引擎检索API，你会看到类似这样的信息：API——Application Programming Interface(应用程序编程接口)，这太抽象了。接下来，我将结合在开发中总结的一些经验，以通俗的方式聊聊API、REST API、RESTful API以及Web Service这四者之间的联系与区别。<br>  <img src="/2021/07/26/正确甄别API-REST-API-RESTFUL-API-和-Web-Service/API&amp;webservice.jpeg" alt="api"></p>
<p>1、API 与 REST API</p>
<p>什么是API?这里引述维基百科给出的定义：应用程序接口（英语：Application Programming Interface，缩写：API；又称为应用编程接口）是软件系统不同组成部分衔接的约定。这个对API的定义太过于广泛和抽象，而通俗的讲，API是一段应用程序与另一段应用程序相互“交流”的方式（协议）。在Web应用程开发中，API是我们通过网络进行数据检索的一种主要方式，API文档将告知你检索数据的URL列表、查询参数、请求方式以及响应状态，其目的是降低Web应用程序开发难度，共享两个应用程序之间的数据（文本、音频、视频、图片等），而屏蔽其内部复杂的实现细节。</p>
<p>REST是Representational State Transfer的缩写，直译过来就是：表述状态的转移。REST API是一组关于如何构建Web应用程序API的架构规则、标准或指导，或者说REST API是遵循API原则的一种架构风格。REST是专门针对Web应用程序而设计的，其目的在于降低开发的复杂度，提高系统的可伸缩性。下面是设计REST风格的系统架构时需要满足或者遵循的一些基本条件和原则：</p>
<p>1、在REST架构中，Web中所有的事物（文本、音频、视频、图片、链接）都可以被统一的抽象为资源（resource）<br>2、在REST架构中，每一个资源都有与之对应的唯一资源标识符（resource identifier）,当资源的状态发生改变时,资源标识符不会发生改变<br>3、在REST架构中，所有的操作都是无状态的。REST架构遵循CRUD原则，所有的资源都可以通过GET、POST、PUT和DELETE这四种行为完成对应的操作。<br>4、可缓存（可选项），在REST架构中需要缓存来有效的处理大批量的请求<br>5、接口一致<br>现在，了解了API和REST API的基本概念，那这两者之间有什么异同？如果按照数学上集合的概念来解释API与REST API之间的联系与区别，API是REST API的超集，REST API 是API的子集；所有的REST API都是API，但不是所有的API都是REST API。更通俗的解释是：所有的男人都是人，但不是所有的人都是男人。</p>
<p>2、REST API 与RESTful API</p>
<p>在第一小节中，了解了什么是REST API，接下来聊聊REST API与RESTful API之间的异同。很多初学者很容易将这两者等同起来，认为RESTful API就是REST API，这可能是单纯的从字面上去理解了，当你深入的去了解两者的本质后，你会发现其实不然。REST API是Web API设计的一种规范或者指导原则，而RESTful API则是这中架构设计原则或者规范的一种具体实现方式。也就是说，RESTful API是REST API的非正式实现方式，因为实现REST API的方式有很多，RESTful API只是其中一种，且没有完全满足REST API的所有设计原则，每个开发者在实现REST 架构时的则重点都会有差别。</p>
<p>很多初学者容易将REST API与RESTful API两者的概念搞混淆，我想可能只是看字面意思，而没有关注它们本身的含义（就像认识中文字一样，有边读边，无边读中间，断章取义了）。这就好比很多人会把变性人等同于女人，变性人可能五官的表象看起来和女人一样，但变性人不能生育，它只是满足了定义一个女性的大多数条件（实现），但本质上不是女人。</p>
<p>接下来，通过一个简单的例子以加深对REST API和RESTful API的理解。下面将给出一个执行CURD操作的RESTful API设计案例：</p>
<p>  <img src="/2021/07/26/正确甄别API-REST-API-RESTFUL-API-和-Web-Service/API.jpeg" alt="http"></p>
<p>说明：resource代指某种资源的名称，可以时student(学生)、teacher(老师)、book(书籍)等等，通常使用名词来表示；{id}则代指某种资源的唯一标识符（resource identifier）</p>
<p>下面是一个具体的小例子，以学生管理为例，设计学生管理的API。学生资源包括ID，姓名和所学课程信息，学生资源信息如下：</p>
<p>  <img src="/2021/07/26/正确甄别API-REST-API-RESTFUL-API-和-Web-Service/resource.jpeg" alt="http2"></p>
<p>现在，我们需要将学生数据保存到数据库，然后执行查询、修改和删除学生数据的操作。学生管理API的使用者调用的API如下：</p>
<p>1、创建学生资源：[POST] <a href="http://www.example.com/student" target="_blank" rel="noopener">http://www.example.com/student</a><br>2、获取所有学生资源：[GET] <a href="http://www.example.com/students" target="_blank" rel="noopener">http://www.example.com/students</a><br>3、获取ID=1001的学生资源：[GET] <a href="http://www.example.com/student/1001" target="_blank" rel="noopener">http://www.example.com/student/1001</a><br>4、修改ID=1001的学生资源：[PUT] <a href="http://www.example.com/student/1001" target="_blank" rel="noopener">http://www.example.com/student/1001</a><br>5、删除ID=1001的学生资源：[DELETE] <a href="http://www.example.com/student/1001" target="_blank" rel="noopener">http://www.example.com/student/1001</a><br>前面的内容说到，API共享数据资源，而屏蔽内部实现，API的使用者（客户端）关注的是资源（读懂数据）,并不需要了解API内部构造;API的提供者（服务端）只关注自己的内部实现，而不关系API使用者（客户端）的状态。为了加深对这一概念的理解，下面给出学生管理API的内部实现示例：</p>
<p>  <img src="/2021/07/26/正确甄别API-REST-API-RESTFUL-API-和-Web-Service/resource-mvc.jpeg" alt="http3"></p>
<p>说明：<br>示例代码是基于Spring MVC进行实现的。</p>
<p>除了上述的内容之外，你还可以通过提供键值对的方式对查询数据进行过滤，如获取所有的学生数据时，只想获取性别为女性的学生数据，则可以通过这样的方式来完成：</p>
<p>[GET] <a href="http://www.example.com/students?gender=female" target="_blank" rel="noopener">http://www.example.com/students?gender=female</a><br>Tip：如果API拥有对数据过滤的功能，对应服务端的API实现代码也需要做调整。</p>
<p>在前面的内容中，我们提到RESTful API是REST API的非正式实现方式或规范。为什么这么说呢？因为在RESTful API的设计中，我们完全可以通过GET的方式完成CURD操作，也可以通过DELETE行为来创建资源，通过POST行为来修改资源，它的实现方式并不严谨或者说并没有严格按照REST API提出的约束条件来进行。所以说RESTful API是REST API的非正式实现方式。</p>
<p>3、REST与Web Service</p>
<p>3-1、什么是Web Service?</p>
<p>如万维网联盟（W3C）所述，Web Service提供了在各种平台和/或框架上运行的不同软件应用程序之间可以进行互操作的标准方法。Web Service的特点是具有良好的互操作性和可扩展性，以及由于使用XML而可以对程序处理过程进行描述。它们可以以松散耦合的方式组合不同的服务以实现复杂的操作。提供简单服务的程序可以通过相互交互，以提供复杂的增值服务。</p>
<p>两个Web Service之间主要通过HTTP网络协议进行通信，如我们熟知的SOA(面向服务的体系架构)，主要依赖于XML-RPC和SOAP(Simple Object Access Protocol，即简单对象访问协议)。</p>
<p>Tip：千万不要将SOA（面向服务体系架构）和SOAP(简单对象访问协议)搞混，前者是一种架构设计形式，后者是一种数据交换协议。</p>
<p>简单的一个示例：假设一个Web Service A提供允许其他应用程序通过URL获取用户信息的功能：[GET] <a href="http://www.abc.com/{id}。id是用户的唯一标识符，请求此URL将获得用户信息。现在假设浏览器、手机、桌面应用程序的用户都要获取服务A提供的用户信息，这三者只需要请求服务A提供的URL地址，并输入用户id信息即可。至于者三个不同客户端的实现方式（编程语言）是什么与服务A" target="_blank" rel="noopener">http://www.abc.com/{id}。id是用户的唯一标识符，请求此URL将获得用户信息。现在假设浏览器、手机、桌面应用程序的用户都要获取服务A提供的用户信息，这三者只需要请求服务A提供的URL地址，并输入用户id信息即可。至于者三个不同客户端的实现方式（编程语言）是什么与服务A</a> 没有任何关系，只要能够解析出服务A返回的XML文档即可。这样，应用程序之间交换数据就可以不用依赖于具体的语言和环境。这就好比不同国家不同语言的人，只要能够知晓对方语言的语法结构，两个人就可以进行交流。</p>
<p>3-2、Web Service的优点</p>
<p>使用Web Service有如下的几个优点：</p>
<p>1、互操作性：Web Service允许应用程序之间进行通信，交换数据和共享服务。<br>2、可用性：Web Service的功能可以从简单的信息查找到复杂的算法计算。<br>3、可重用性：Web Service之间可以相互组合，以提供更为复杂的服务，由于其互操作性的特点，可以轻松的在其他的服务中重用Web Service组件,提高了服务的重用率。<br>4、易于部署：Web Service可以部署在基于Internet标准的容器中，如Apache、Axis2等，以提供HTTP或者WSDL（网络服务定义语言）驱动的服务。<br>5、成本低：Web Service是通过打包成Web服务组件进行部署，从而降低了使用的成本。<br>3-3、Web Service的类型</p>
<p>目前，Web Service主要有两大流派：</p>
<p>1、基于SOAP的Web Service : SOAP(简单对象访问协议)是一种基于XML的协议，用以访问Web Service。其接口以机器可处理的格式进行描述，称为WSDL(Web服务定义语言)文档。通过使用标准的的XML文档来描述Web Service，在XML文件中，会详细记录接口的信息，如消息的格式、传输协议以及交互的位置等信息。<br>2、基于REST的Web Service ：REST(Representational State Transfer)是一种软件架构，它使用JSON来描述数据格式，最重要的是HTTP传输协议对REST来说是非必须的。<br>3-4、REST与SOAP的区别和联系</p>
<p>下面，通过一张表格来对比REST与SOAP之间的异同：</p>
<p>  <img src="/2021/07/26/正确甄别API-REST-API-RESTFUL-API-和-Web-Service/soap&amp;REST.jpeg" alt="http4"></p>
<p>总结</p>
<p>如上所述，我们了解了什么是API，什么是REST API,什么是RESTful API以及Web Service的相关概念。API代表应用程序编程接口，是一种较为宽泛的定义或者说是一种协议，作为软件程序之间相互通信的接口而存在。REST API是API的一个子集，所有的REST API都是API；RESTful API是对REST API架构风格的一种非正式实现方式。API与Web Service都是服务提供者和服务消费者之间的通信手段。最后，为了能够快速的识别API与Web Service之间的差异，将这两种手段的不同之处整理成对照表如下：</p>
<p>  <img src="/2021/07/26/正确甄别API-REST-API-RESTFUL-API-和-Web-Service/x.jpeg" alt="http5"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://chenfengying.github.io/2021/07/26/正确甄别API-REST-API-RESTFUL-API-和-Web-Service/" data-id="cm780tvp0001bc0vl4l2ftn48" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Deutsch/">Deutsch</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/English-Grammer/">English Grammer</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Flask/">Flask</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Github/">Github</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Internet-Basic/">Internet Basic</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Jmeter/">Jmeter</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Nginx/">Nginx</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/SQL/">SQL</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Selenium/">Selenium</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Test-Basic/">Test Basic</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Test-Basic-Security/">Test Basic-Security</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/TestNG/">TestNG</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Automation/">Automation</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Automation/" style="font-size: 10px;">Automation</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/02/">February 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">August 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">July 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">October 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">June 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/02/16/Java-Collection/">Java Collection</a>
          </li>
        
          <li>
            <a href="/2022/08/27/Jmeter-issue/">Jmeter issue</a>
          </li>
        
          <li>
            <a href="/2022/07/03/eclipse-connect-the-mysql-database/">eclipse connect the mysql database</a>
          </li>
        
          <li>
            <a href="/2021/10/11/pycharm-调试技巧/">pycharm 调试技巧</a>
          </li>
        
          <li>
            <a href="/2021/10/11/python3-typing/">python3- typing</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2025 Summer<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>